"use strict";
// XXX maybe this should just be its own graphql-signature package
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
// In Engine, we want to group requests making the same query together, and
// treat different queries distinctly. But what does it mean for two queries to
// be "the same"?  And what if you don't want to send the full text of the query
// to Apollo Engine's servers, either because it contains sensitive data or
// because it contains extraneous operations or fragments?
//
// To solve these problems, EngineReportingAgent has the concept of
// "signatures". We don't (by default) send the full query string of queries to
// the Engine servers. Instead, each trace has its query string's "signature".
//
// The default signature implementation drops unused operations and fragments
// from the query document and formats it as a GraphQL query with all extraneous
// whitespace removed.
//
// However, you can specify any function mapping a GraphQL query AST
// (DocumentNode) to string as your signature algorithm by providing it as the
// 'signature' option to the EngineReportingAgent constructor. Ideally, your
// signature should be a valid GraphQL query, though as of now the Engine
// servers do not re-parse your signature and do not expect it to match the
// execution tree in the trace.
//
// In addition to providing the defaultSignature function, this file also
// provides several useful building blocks for writing your own signature
// function. This includes:
//
// - dropUnusedDefinitions, which removes operations and fragments that
//   aren't going to be used in execution (part of defaultSignature)
// - printWithReducedWhitespace, a variant on graphql-js's 'print'
//   which gets rid of unneeded whitespace (part of defaultSignature)
// - hideLiterals, which replaces all numeric and string literals as well
//   as list and object input values with "empty" values
// - sortAST, which sorts the children of most multi-child nodes
//   consistently
// - removeAliases, which removes field aliasing from the query
//
// Historical note: the default signature algorithm of the Go engineproxy
// performed all of the above operations, and the Engine servers then re-ran a
// mostly identical signature implementation on received traces. This was
// primarily to deal with edge cases where some users used literal interpolation
// instead of GraphQL variables, included randomized alias names, etc. In
// addition, the servers relied on the fact that dropUnusedDefinitions had been
// called in order (and that the signature could be parsed as GraphQL) to
// extract the name of the operation for display. This caused confusion, as the
// query document shown in the Engine UI wasn't the same as the one actually
// sent. apollo-engine-reporting uses a new reporting API which requires it to
// explicitly include the operation name with each signature; this means that
// the server no longer needs to parse the signature or run its own signature
// algorithm on it, and the details of the signature algorithm are now up to the
// reporting agent. We decided to make the default signature algorithm be less
// invasive than in engineproxy, and to allow users with special needs to add
// the other building blocks in when necessary.
var lodash_1 = require("lodash");
var graphql_1 = require("graphql");
// Replace numeric, string, list, and object literals with "empty"
// values. Leaves enums alone (since there's no consistent "zero" enum). This
// can help combine similar queries if you substitute values directly into
// queries rather than use GraphQL variables, and can hide sensitive data in
// your query (say, a hardcoded API key) from Engine servers, but in general
// avoiding those situations is better than working around them.
function hideLiterals(ast) {
    return graphql_1.visit(ast, {
        IntValue: function (node) {
            return __assign({}, node, { value: '0' });
        },
        FloatValue: function (node) {
            return __assign({}, node, { value: '0' });
        },
        StringValue: function (node) {
            return __assign({}, node, { value: '', block: false });
        },
        ListValue: function (node) {
            return __assign({}, node, { values: [] });
        },
        ObjectValue: function (node) {
            return __assign({}, node, { fields: [] });
        },
    });
}
exports.hideLiterals = hideLiterals;
// A GraphQL query may contain multiple named operations, with the operation to
// use specified separately by the client. This transformation drops unused
// operations from the query, as well as any fragment definitions that are not
// referenced.  (In general we recommend that unused definitions are dropped on
// the client before sending to the server to save bandwidth and parsing time.)
function dropUnusedDefinitions(ast, operationName) {
    var separated = graphql_1.separateOperations(ast)[operationName];
    if (!separated) {
        // If the given operationName isn't found, just make this whole transform a
        // no-op instead of crashing.
        return ast;
    }
    return separated;
}
exports.dropUnusedDefinitions = dropUnusedDefinitions;
// Like lodash's sortBy, but sorted(undefined) === undefined rather than []. It
// is a stable non-in-place sort.
function sorted(items) {
    var iteratees = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        iteratees[_i - 1] = arguments[_i];
    }
    if (items) {
        return lodash_1.sortBy.apply(void 0, [items].concat(iteratees));
    }
    return undefined;
}
// sortAST sorts most multi-child nodes alphabetically. Using this as part of
// your signature calculation function may make it easier to tell the difference
// between queries that are similar to each other, and if for some reason your
// GraphQL client generates query strings with elements in nondeterministic
// order, it can make sure the queries are treated as identical.
function sortAST(ast) {
    return graphql_1.visit(ast, {
        OperationDefinition: function (node) {
            return __assign({}, node, { variableDefinitions: sorted(node.variableDefinitions, 'variable.name.value') });
        },
        SelectionSet: function (node) {
            return __assign({}, node, { 
                // Define an ordering for field names in a SelectionSet.  Field first,
                // then FragmentSpread, then InlineFragment.  By a lovely coincidence,
                // the order we want them to appear in is alphabetical by node.kind.
                // Use sortBy instead of sorted because 'selections' is not optional.
                selections: lodash_1.sortBy(node.selections, 'kind', 'name.value') });
        },
        Field: function (node) {
            return __assign({}, node, { arguments: sorted(node.arguments, 'name.value') });
        },
        FragmentSpread: function (node) {
            return __assign({}, node, { directives: sorted(node.directives, 'name.value') });
        },
        InlineFragment: function (node) {
            return __assign({}, node, { directives: sorted(node.directives, 'name.value') });
        },
        FragmentDefinition: function (node) {
            return __assign({}, node, { directives: sorted(node.directives, 'name.value'), variableDefinitions: sorted(node.variableDefinitions, 'variable.name.value') });
        },
        Directive: function (node) {
            return __assign({}, node, { arguments: sorted(node.arguments, 'name.value') });
        },
    });
}
exports.sortAST = sortAST;
// removeAliases gets rid of GraphQL aliases, a feature by which you can tell a
// server to return a field's data under a different name from the field
// name. Maybe this is useful if somebody somewhere inserts random aliases into
// their queries.
function removeAliases(ast) {
    return graphql_1.visit(ast, {
        Field: function (node) {
            return __assign({}, node, { alias: undefined });
        },
    });
}
exports.removeAliases = removeAliases;
// Like the graphql-js print function, but deleting whitespace wherever
// feasible. Specifically, all whitespace (outside of string literals) is
// reduced to at most one space, and even that space is removed anywhere except
// for between two alphanumerics.
function printWithReducedWhitespace(ast) {
    // In a GraphQL AST (which notably does not contain comments), the only place
    // where meaningful whitespace (or double quotes) can exist is in
    // StringNodes. So to print with reduced whitespace, we:
    // - temporarily sanitize strings by replacing their contents with hex
    // - use the default GraphQL printer
    // - minimize the whitespace with a simple regexp replacement
    // - convert strings back to their actual value
    // We normalize all strings to non-block strings for simplicity.
    var sanitizedAST = graphql_1.visit(ast, {
        StringValue: function (node) {
            return __assign({}, node, { value: Buffer.from(node.value, 'utf8').toString('hex'), block: false });
        },
    });
    var withWhitespace = graphql_1.print(sanitizedAST);
    var minimizedButStillHex = withWhitespace
        .replace(/\s+/g, ' ')
        .replace(/([^_a-zA-Z0-9]) /g, function (_, c) { return c; })
        .replace(/ ([^_a-zA-Z0-9])/g, function (_, c) { return c; });
    return minimizedButStillHex.replace(/"([a-f0-9]+)"/g, function (_, hex) {
        return JSON.stringify(Buffer.from(hex, 'hex').toString('utf8'));
    });
}
exports.printWithReducedWhitespace = printWithReducedWhitespace;
// The default signature function consists of removing unused definitions
// and whitespace.
// XXX consider caching somehow
function defaultSignature(ast, operationName) {
    return printWithReducedWhitespace(dropUnusedDefinitions(ast, operationName));
}
exports.defaultSignature = defaultSignature;
//# sourceMappingURL=signature.js.map