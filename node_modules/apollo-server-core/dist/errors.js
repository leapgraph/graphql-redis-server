"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const logging_1 = require("./logging");
class ApolloError extends Error {
    constructor(message, code, properties) {
        super(message);
        if (properties) {
            Object.keys(properties).forEach(key => {
                this[key] = properties[key];
            });
        }
        if (!this.name) {
            Object.defineProperty(this, 'name', { value: 'ApolloError' });
        }
        this.extensions = { code };
    }
}
exports.ApolloError = ApolloError;
function enrichError(error, debug = false) {
    const expanded = {};
    Object.defineProperties(expanded, {
        name: {
            value: error.name,
        },
        message: {
            value: error.message,
            enumerable: true,
            writable: true,
        },
        locations: {
            value: error.locations || undefined,
            enumerable: true,
        },
        path: {
            value: error.path || undefined,
            enumerable: true,
        },
        nodes: {
            value: error.nodes || undefined,
        },
        source: {
            value: error.source || undefined,
        },
        positions: {
            value: error.positions || undefined,
        },
        originalError: {
            value: error.originalError,
        },
    });
    expanded.extensions = Object.assign({}, error.extensions, { code: (error.extensions && error.extensions.code) || 'INTERNAL_SERVER_ERROR', exception: Object.assign({}, (error.extensions && error.extensions.exception), error.originalError) });
    delete expanded.extensions.exception.extensions;
    if (debug && !expanded.extensions.exception.stacktrace) {
        expanded.extensions.exception.stacktrace =
            (error.originalError &&
                error.originalError.stack &&
                error.originalError.stack.split('\n')) ||
                (error.stack && error.stack.split('\n'));
    }
    if (Object.keys(expanded.extensions.exception).length === 0) {
        delete expanded.extensions.exception;
    }
    return expanded;
}
function toApolloError(error, code = 'INTERNAL_SERVER_ERROR') {
    let err = error;
    if (err.extensions) {
        err.extensions.code = code;
    }
    else {
        err.extensions = { code };
    }
    return err;
}
exports.toApolloError = toApolloError;
function fromGraphQLError(error, options) {
    const copy = options && options.errorClass
        ? new options.errorClass(error.message)
        : new ApolloError(error.message);
    Object.keys(error).forEach(key => {
        copy[key] = error[key];
    });
    copy.extensions = Object.assign({}, copy.extensions, error.extensions);
    if (!copy.extensions.code) {
        copy.extensions.code = (options && options.code) || 'INTERNAL_SERVER_ERROR';
    }
    Object.defineProperty(copy, 'originalError', { value: {} });
    Object.getOwnPropertyNames(error).forEach(key => {
        Object.defineProperty(copy.originalError, key, { value: error[key] });
    });
    return copy;
}
exports.fromGraphQLError = fromGraphQLError;
class SyntaxError extends ApolloError {
    constructor(message) {
        super(message, 'GRAPHQL_PARSE_FAILED');
        Object.defineProperty(this, 'name', { value: 'SyntaxError' });
    }
}
exports.SyntaxError = SyntaxError;
class ValidationError extends ApolloError {
    constructor(message) {
        super(message, 'GRAPHQL_VALIDATION_FAILED');
        Object.defineProperty(this, 'name', { value: 'ValidationError' });
    }
}
exports.ValidationError = ValidationError;
class AuthenticationError extends ApolloError {
    constructor(message) {
        super(message, 'UNAUTHENTICATED');
        Object.defineProperty(this, 'name', { value: 'AuthenticationError' });
    }
}
exports.AuthenticationError = AuthenticationError;
class ForbiddenError extends ApolloError {
    constructor(message) {
        super(message, 'FORBIDDEN');
        Object.defineProperty(this, 'name', { value: 'ForbiddenError' });
    }
}
exports.ForbiddenError = ForbiddenError;
class PersistedQueryNotFoundError extends ApolloError {
    constructor() {
        super('PersistedQueryNotFound', 'PERSISTED_QUERY_NOT_FOUND');
        Object.setPrototypeOf(this, PersistedQueryNotFoundError.prototype);
        Object.defineProperty(this, 'name', {
            value: 'PersistedQueryNotFoundError',
        });
    }
}
exports.PersistedQueryNotFoundError = PersistedQueryNotFoundError;
class PersistedQueryNotSupportedError extends ApolloError {
    constructor() {
        super('PersistedQueryNotSupported', 'PERSISTED_QUERY_NOT_SUPPORTED');
        Object.setPrototypeOf(this, PersistedQueryNotSupportedError.prototype);
        Object.defineProperty(this, 'name', {
            value: 'PersistedQueryNotSupportedError',
        });
    }
}
exports.PersistedQueryNotSupportedError = PersistedQueryNotSupportedError;
class BadUserInputError extends ApolloError {
    constructor(message, properties) {
        super(message, 'BAD_USER_INPUT', properties);
        Object.defineProperty(this, 'name', { value: 'BadUserInputError' });
    }
}
exports.BadUserInputError = BadUserInputError;
function formatApolloErrors(errors, options) {
    if (!options) {
        return errors.map(error => enrichError(error));
    }
    const { formatter, debug, logFunction } = options;
    const flattenedErrors = [];
    errors.forEach(error => {
        if (Array.isArray(error.errors)) {
            error.errors.forEach(e => flattenedErrors.push(e));
        }
        else if (error.originalError &&
            Array.isArray(error.originalError.errors)) {
            error.originalError.errors.forEach(e => flattenedErrors.push(e));
        }
        else {
            flattenedErrors.push(error);
        }
    });
    const enrichedErrors = flattenedErrors.map(error => enrichError(error, debug));
    if (!formatter) {
        return enrichedErrors;
    }
    return enrichedErrors.map(error => {
        try {
            return formatter(error);
        }
        catch (err) {
            logFunction &&
                logFunction({
                    action: logging_1.LogAction.cleanup,
                    step: logging_1.LogStep.status,
                    data: err,
                    key: 'error',
                });
            if (debug) {
                return enrichError(err, debug);
            }
            else {
                const newError = fromGraphQLError(new graphql_1.GraphQLError('Internal server error'));
                return enrichError(newError, debug);
            }
        }
    });
}
exports.formatApolloErrors = formatApolloErrors;
//# sourceMappingURL=errors.js.map