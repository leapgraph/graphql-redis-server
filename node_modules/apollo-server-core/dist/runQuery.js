"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const graphql_extensions_1 = require("graphql-extensions");
const apollo_tracing_1 = require("apollo-tracing");
const apollo_cache_control_1 = require("apollo-cache-control");
const errors_1 = require("./errors");
const logging_1 = require("./logging");
function isQueryOperation(query, operationName) {
    const operationAST = graphql_1.getOperationAST(query, operationName);
    return operationAST.operation === 'query';
}
function runQuery(options) {
    return Promise.resolve().then(() => doRunQuery(options));
}
exports.runQuery = runQuery;
function doRunQuery(options) {
    if (options.queryString && options.parsedQuery) {
        throw new Error('Only supply one of queryString and parsedQuery');
    }
    if (!(options.queryString || options.parsedQuery)) {
        throw new Error('Must supply one of queryString and parsedQuery');
    }
    const debugDefault = process.env.NODE_ENV !== 'production' && process.env.NODE_ENV !== 'test';
    const debug = options.debug !== undefined ? options.debug : debugDefault;
    const context = options.context || {};
    const extensions = options.extensions ? options.extensions.map(f => f()) : [];
    if (options.tracing) {
        extensions.push(new apollo_tracing_1.TracingExtension());
    }
    if (options.cacheControl === true) {
        extensions.push(new apollo_cache_control_1.CacheControlExtension());
    }
    else if (options.cacheControl) {
        extensions.push(new apollo_cache_control_1.CacheControlExtension(options.cacheControl));
    }
    if (options.logFunction) {
        extensions.push(new logging_1.LogFunctionExtension(options.logFunction));
    }
    const extensionStack = new graphql_extensions_1.GraphQLExtensionStack(extensions);
    if (extensions.length > 0) {
        graphql_extensions_1.enableGraphQLExtensions(options.schema);
    }
    context._extensionStack = extensionStack;
    const requestDidEnd = extensionStack.requestDidStart({
        request: options.request,
        queryString: options.queryString,
        parsedQuery: options.parsedQuery,
        operationName: options.operationName,
        variables: options.variables,
    });
    return Promise.resolve()
        .then(() => {
        let documentAST;
        if (options.parsedQuery) {
            documentAST = options.parsedQuery;
        }
        else if (!options.queryString) {
            throw new Error('Must supply one of queryString and parsedQuery');
        }
        else {
            const parsingDidEnd = extensionStack.parsingDidStart({
                queryString: options.queryString,
            });
            let graphqlParseErrors;
            try {
                documentAST = graphql_1.parse(options.queryString);
            }
            catch (syntaxError) {
                graphqlParseErrors = errors_1.formatApolloErrors([
                    errors_1.fromGraphQLError(syntaxError, {
                        errorClass: errors_1.SyntaxError,
                    }),
                ], {
                    formatter: options.formatError,
                    debug,
                });
            }
            finally {
                parsingDidEnd(...(graphqlParseErrors || []));
                if (graphqlParseErrors) {
                    return Promise.resolve({ errors: graphqlParseErrors });
                }
            }
        }
        if (options.nonQueryError &&
            !isQueryOperation(documentAST, options.operationName)) {
            throw options.nonQueryError;
        }
        let rules = graphql_1.specifiedRules;
        if (options.validationRules) {
            rules = rules.concat(options.validationRules);
        }
        const validationDidEnd = extensionStack.validationDidStart();
        let validationErrors;
        try {
            validationErrors = graphql_1.validate(options.schema, documentAST, rules);
        }
        catch (validationThrewError) {
            validationErrors = [validationThrewError];
        }
        finally {
            try {
                if (validationErrors) {
                    validationErrors = errors_1.formatApolloErrors(validationErrors.map(err => errors_1.fromGraphQLError(err, { errorClass: errors_1.ValidationError })), {
                        formatter: options.formatError,
                        logFunction: options.logFunction,
                        debug,
                    });
                }
            }
            finally {
                validationDidEnd(...(validationErrors || []));
                if (validationErrors && validationErrors.length) {
                    return Promise.resolve({
                        errors: validationErrors,
                    });
                }
            }
        }
        const executionArgs = {
            schema: options.schema,
            document: documentAST,
            rootValue: options.rootValue,
            contextValue: context,
            variableValues: options.variables,
            operationName: options.operationName,
            fieldResolver: options.fieldResolver,
        };
        const executionDidEnd = extensionStack.executionDidStart({
            executionArgs,
        });
        return Promise.resolve()
            .then(() => graphql_1.execute(executionArgs))
            .catch(executionError => {
            return {
                errors: [errors_1.fromGraphQLError(executionError)],
            };
        })
            .then(result => {
            let response = {
                data: result.data,
            };
            if (result.errors) {
                response.errors = errors_1.formatApolloErrors([...result.errors], {
                    formatter: options.formatError,
                    logFunction: options.logFunction,
                    debug,
                });
            }
            executionDidEnd(...(result.errors || []));
            const formattedExtensions = extensionStack.format();
            if (Object.keys(formattedExtensions).length > 0) {
                response.extensions = formattedExtensions;
            }
            if (options.formatResponse) {
                response = options.formatResponse(response, options);
            }
            return response;
        });
    })
        .catch(err => {
        requestDidEnd(err);
        throw err;
    })
        .then(graphqlResponse => {
        extensionStack.willSendResponse({ graphqlResponse });
        requestDidEnd();
        return graphqlResponse;
    });
}
//# sourceMappingURL=runQuery.js.map